#!/usr/bin/env bash

#
# See <https://voz.dev/articles/git/wt>
#

set -euo pipefail

copy_worktree_files() {
  local src=$1 dest=$2
  local include_file="$src/.worktreeinclude"
  local gitignore_file="$src/.gitignore"
  local use_include=false

  if [[ -f "$include_file" ]]; then
    use_include=true
  elif [[ ! -f "$gitignore_file" ]]; then
    return 0
  fi

  local patterns_file="${use_include:+$include_file}"
  : "${patterns_file:=$gitignore_file}"

  while IFS= read -r pattern || [[ -n "$pattern" ]]; do
    [[ -z "$pattern" || "$pattern" =~ ^# || "$pattern" =~ ^! ]] && continue

    # If using .worktreeinclude, validate pattern is in .gitignore
    if $use_include && [[ -f "$gitignore_file" ]]; then
      if ! grep -qFx "$pattern" "$gitignore_file"; then
        echo "wt: skipping '$pattern' (not in .gitignore)" >&2
        continue
      fi
    fi

    # Strip trailing slash for directories
    pattern=${pattern%/}
    # Copy matching files
    for file in "$src"/$pattern; do
      [[ -e "$file" ]] || continue
      local relpath=${file#"$src/"}
      local destpath="$dest/$relpath"
      mkdir -p "$(dirname "$destpath")"
      cp -R "$file" "$destpath"
      echo "wt: copied $relpath"
    done
  done < "$patterns_file"
}

show_help() {
  cat <<'EOF'
Usage: wt [command] [options]
Commands:
  <branch>                   Add a worktree (shorthand for 'wt add')
  list|ls                    Show active worktrees
  add [-b base] <branch>     Add a worktree; path defaults to ../<repo>-<branch>
  remove|rm <path|branch>    Remove a worktree by path or branch name
  prune                      Run git worktree prune
Examples:
  wt feature/login
  wt add -b main feature/login
  wt remove feature/login
EOF
}

[[ $# -eq 0 || "$1" =~ ^(help|--help)$ ]] && { show_help; exit 0; }

git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "wt: run inside a git repository" >&2; exit 1; }

repo_root=$(git rev-parse --show-toplevel)
repo_name=$(basename "$repo_root")

cmd=$1
case "$cmd" in
  list|ls|prune|add|new|remove|rm) shift ;;
  *) cmd="add" ;;  # Default to add for branch names
esac

case "$cmd" in
list|ls) git worktree list "$@" ;;
prune) git worktree prune "$@" ;;
add|new)
  base="" path=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b|--base) base=$2; shift 2 ;;
      -p|--path) path=$2; shift 2 ;;
      -h|--help) show_help; exit 0 ;;
      *) [[ -z "${branch:-}" ]] && branch=$1 || path=$1; shift ;;
    esac
  done
  [[ -z "${branch:-}" ]] && { echo "wt add: branch name required" >&2; exit 1; }
  : "${path:=$(dirname "$repo_root")/${repo_name}-${branch//\//-}}"

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$path" "$branch"
  elif git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    git worktree add --track -b "$branch" "$path" "origin/$branch"
  elif [[ -n "$base" ]]; then
    git worktree add -b "$branch" "$path" "$base"
  else
    echo "wt add: branch '$branch' not found. Use --base <existing-branch> to create it." >&2
    exit 1
  fi
  copy_worktree_files "$repo_root" "$path"
  ;;
remove|rm)
  [[ $# -eq 0 ]] && { echo "wt remove: provide a path or branch name" >&2; exit 1; }
  input=$1
  if [[ -d "$input" ]]; then
    target=$input
  else
    target=$(git worktree list --porcelain | awk -v b="$input" '/^worktree /{w=$2} /^branch /{gsub(/refs\/heads\//,"",$2); if($2==b){print w;exit}}')
    [[ -z "$target" ]] && guess="$(dirname "$repo_root")/${repo_name}-${input//\//-}" && [[ -d "$guess" ]] && target=$guess
  fi
  [[ -z "${target:-}" ]] && { echo "wt remove: unable to resolve worktree for '$input'" >&2; exit 1; }
  git worktree remove "$target"
  ;;
esac
